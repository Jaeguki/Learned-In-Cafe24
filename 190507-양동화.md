# 톰캣 최종분석 (들어가기~2장)

### 작성자
양동화


## 들어가기
### 서블릿 컨테이너의 작동 원리
- 요청 객체(request object) 생성 후, 호출된 서블릿이 사용할 파라미터, 헤더, 쿠기, 질의문, URI와 같은 정보를 요청 객체에 채운다.
- 서블릿이 웹 클라이언트에 응답을 보낼 때 사용할 응답 객체(response object)를 생성한다.
- 서블릿의 service 메소드에 요청 객체와 응답 객체를 전달해 호출한다. 여기서 서블릿은 요청 객체로부터 값을 읽어들이고 응답 객체에 값을 쓴다.

### 카탈리나의 구성도
카탈리나는 크게 커넥터와 컨테이너라는 2개의 주요 모듈로 구성되어 있다.

\- | 커넥터(Connector) | 컨테이너(Container)
--- | --- | ---
설명 | 요청을 컨테이너에 연결해 주는 모듈 | 웹 서버의 내부에서 서블릿을 실행하기 위한 실행 환경을 제공하는 것. 대표적으로 Tomcat, 웹로직, Resin 등이 있다.
역할 | 전달 받은 각 HTTP 요청에 대해 요청 객체와 응답 객체를 구성한 후, 컨테이너에 전달 | 커넥터로부터 요청 및 응답 객체를 전달받고, 서블릿의 service 메소드를 호출할 책임을 진다.

### 톰캣 버전 비교
책에서 다루는 4, 5버전과 차이가 크다고 알려진 7버전, 많이 사용되는 8버전에 대해 각각 비교해보았다.

버전 | 4 | 5 | 7 | 8
--- | --- | --- | --- | ---
서블릿 사양 | 2.4 | 2.5 | 3.0 | 3.1
JSP 사양 | 1.2 | 2.0 | 2.2 | 2.3
EL 사양 | N/A | N/A | 2.1 | 3.0
WebSocket 사양 | N/A | N/A | 1.0 | 1.0
최소 Java 버전 | 1.3 | 1.4 | 1.6 (WebSocket 1.0 1.7 필요) | 1.7

- EL: Java Bean의 property와 묵시적 객체에 대한 데이터 접근을 간단하게 하기 위해 만들어진 표현언어(Expression Language)
   - ${expression}

### 각 장의 소개
1. 간단한 HTTP 서버
2. 간단한 서블릿 컨테이너
3. 간단한 커넥터
4. 톰캣 4의 기본 커넥터
5. 컨테이너 모듈(engine, host, context, wrapper)
6. LifeCycle 인터페이스 (카탈리나 컴포넌트의 생명 주기)
7. 로거(logger) - 에러 등 메시지 기록하는 컴포넌트
8. 로더(loader) - 웹 어플리케이션이 사용하는 서블릿과 클래스 로드하는 컴포넌트
9. 매니저 - 사용자의 세션을 관리하는 컴포넌트
10. 웹 어플리케이션의 보안 - 접근 제어, 보안 주체, 보안 역할, 로그인 설정, 인증자 등
11. `org.apache.catalina.core.StandardWrapper` 클래스 자세히 살펴보기. 필터와 서블릿의 service 메소드 호출되는 원리 알아보기
12. `org.apache.catalina.core.StandardContext` 클래스 살펴보기. StandardContext 객체를 설정하는 방법, 각 HTTP 요청이 들어왔을 때 일어나는 일, 자동 재로딩의 원리, 관련 컴포넌트에서 정기적인 작업을 수행하는 스레드를 어떻게 톰캣 5가 공유하고 사용하는지 알아보기
13. host, engine 컨테이너 소개
14. 서버 컴포넌트(서블릿 컨테이너 전체의 세련된 시작/중지 방법 제공)와 서비스 컴포넌트(하나의 컨테이너와 하나 이상의 커넥터를 보유하는 컴포넌트). 서버와 서비스 사용법
15. 다이제스터(Digester) 라이브러리를 통해 웹 어플리케이션의 설정이 어떻게 이뤄지는지. (XML 문서를 자바 객체로 변환해 주는 기능을 하는데, 어떻게 변환할 수 있는지 알아본다.)
16. 사용자가 톰캣을 종료할 때 필요한 뒤처리(clean-up)을 항상 할 수 있게 하는 종료 후크(shutdown hook)
17. 배치 파일(batch file)이나 쉘 스크립트(shell script)를 써서 톰캣을 시작/중지 하는 방법
18. 배치자(deployer) - 웹 어플리케이션을 배치, 설치하는 역할을 맡음
19. ContainerServlet - 서블릿이 카탈리나의 내부 객체에 접근할 수 있게 해주는 인터페이스 / 배치된 어플리케이션을 관리할 수 있는 관리자 어플리케이션(manager application)에 관하여
20. JMX에 관해서, 톰캣이 MBean을 만들어서 자신의 내부 객체를 쉽게 관리하는 방법에 대하여 알아보기


## 1. 간단한 웹 서버
### Hypertext Transfer Protocol(HTTP)
- 인터넷에서 웹 서버와 브라우저가 데이터를 주고받는 데 필요한 프로토콜
- 요청/응답 방식
- 신뢰성 높은 TCP 연결 사용, 포트 80번 기본 사용

#### HTTP 버전 비교
버전 | 0.9 | 1.0 | 1.1 | 2.0
--- | --- | --- | --- | ---
설명 | 원-라인 프로토콜 | 확장성 만들기 | 표준 프로토콜 | 더 나은 성능을 위한 프로토콜
요청 | 단일 라인의 요청, 리소스에 대한 경로로 가능한 메서드는 GET이 유일 | 버전 정보가 각 요청 사이내로 전송되기 시작함 | 파이프라이닝을 추가하여, 첫 번째 요청에 대한 응답이 완전히 전송되기 이전에 두 번째 요청 전송을 가능케 하여, 커뮤니케이션 지연 시간(latency)을 낮춤 | 병렬 요청이 동일한 커넥션 상에서 다루어질 수 있는 다중화 프로토콜로, 순서를 제거해주고 HTTP/1.x 프로토콜의 제약사항을 막아줌<br>전송된 데이터의 분명한 중복과 그런 데이터로부터 유발된 불필요한 오버헤드를 제거하면서, 연속된 요청 사이의 매우 유사한 내용으로 존재하는 헤더들을 압축시킨다.
응답 | 헤더의 존재 없이 HTML 파일만 전송됨 | 헤더가 생김. 상태 코드 라인이 응답의 시작 부분에 붙어 전송됨: 브라우저가 요청의 결과에 대한 동작을 할 수 있게 됨 | Host 헤더로 인해, 동일 IP 주소에 다른 도메인을 호스트하는 기능이 서버 코로케이션을 가능케 한다. | 서버로 하여금 사전에 클라이언트 캐시를 서버 푸쉬라고 불리는 메커니즘에 의해, 필요하게 될 데이터로 채워넣도록 허용한다.
추가된 기능 | . | 헤더의 존재로, HTML 파일들 외에 다른 문서들을 전송하는 기능이 추가됨(Content-Type) | 언어, 인코딩 혹은 타입을 포함한 컨텐츠 협상이 도입되어, 클라이언트와 서버로 하여금 교환하려는 가장 적합한 컨텐츠에 대한 동의를 가능하게 함<br>커넥션이 재사용될 수 있게 하여, 웹페이지 탐색 시간을 절약함 | 텍스트 프로토콜이라기보다는 이진 프로토콜로, 더 이상 읽을 수도 없고 수작업을 만들어낼 수 없다. 이런 결점에 대한 보상으로 새로운 최적화 기술이 구현될 수 있다.

### HTTP 요청
- 구성
   - 메소드 - URI(Uniform Resource Identifier) - 프로토콜/버전
   - 요청 헤더(Request header): 클라이언트 환경에 대한 유용한 정보(브라우저에 설정되어 있는 언어, 문서 본체의 길이 등)를 포함한다. 각각의 개별 헤더 정보는 캐리지 리턴과 개행 문자(CRLF)로 구분된다.
   - 헤더와 본체 사이에는 빈 줄이 하나 존재하는데, 이것이 헤더와 본체를 구분한다.
   - 문서 본체(Entity body)

### HTTP 응답
- 구성
   - 프로토콜 - 상태 코드(Status code) - 설명(description)
   - 응답 헤더(Response header): 요청 헤더와 마찬가지로 클라이언트에게 유용한 정보를 포함한다.
   - 여기에도 헤더와 본체 사이에 빈 줄을 삽입하여 둘을 구분한다.
   - 문서 본체(Entity body): HTML 컨텐트 자체

### Socket 클래스
- 소켓: 네트워크 연결에 있어서의 끝점(endpoint)에 해당하며, 애플리케이션은 소켓을 사용해 네트워크에 데이터를 읽거나 쓸 수 있다.
- 소프트웨어 어플리케이션은 네트워크 연결을 통해 바이트 스트림(byte stream)을 전송하고 수신함으로써 서로간에 통신이 가능하다.
- 메시지를 전달하려면 상대방 컴퓨터의 **IP**와 상대방 어플리케이션 소켓이 사용하는 **포트 번호**를 알아야 한다.
- Java - `java.net.Socket`: 어디에서든 원격 서버 어플리케이션에 연결할 수 있는 '클라이언트' 소켓을 나타낸다.

### ServerSocket 클래스
- 서버 어플리케이션의 경우, 클라이언트가 언제 접속을 시도할지 알 수 없는 상태에서 항상 대기하고 있어야 한다.
- Java - `java.net.ServerSocket`
- 클라이언트의 연결 요청을 기다리다가 연결 요청을 받아들이면, 서버 소켓을 Socket 인스턴스를 생성해 클라이언트와의 통신을 처리하게 한다.
- 리스닝 할 IP 주소(=바인딩 주소(`java.net.InetAddress`)), 포트 번호, 백로그(연결 요청의 최대 큐 길이(=수락할 수 있는 연결 요청의 최대 개수))


## 2. 간단한 서블릿 컨테이너
### javax.servlet.Servlet 인터페이스
서블릿 프로그래밍은 `javax.servlet` 패키지와 `javax.servlet.http` 패키지의 클래스와 인터페이스를 통해 이뤄진다. 이들 클래스와 인터페이스 가운데 `javax.servlet.Servlet`은 가장 중요한 인터페이스로, 모든 서블릿은 이 인터페이스를 구현(implement)하거나 이 인터페이스를 구현한 클래스를 확장(extend)해야 한다.

#### Servlet 인터페이스의 5가지 메소드
1. init
   - 생명주기와 관련된 메소드. 서블릿 클래스를 인스턴스화한 뒤, 서블릿 컨테이너가 호출하는 메소드이다. 서블릿이 어떤 요청을 받기 전에 성공적으로 끝나야 한다.
2. service
   - 생명주기와 관련된 메소드. 서블릿의 요청이 있을 때마다 호출되는 메소드이다. 서블릿의 생명주기 동안 자주 호출된다.
3. destroy
   - 생명주기와 관련된 메소드. 서블릿 컨테이너가 서비스 영역으로부터 서블릿 인스턴스를 제거하기 앞서 해당 서블릿의 destroy 메소드를 호출한다. 서블릿의 service 메소드로부터 모든 스레드가 빠져나간 뒤나 제한시간이 지난 뒤에 호출된다. 서블릿이 소유하고 있던 메모리, 파일 핸들, 스레드 등과 같은 자원을 깨끗하게 반환할 수 있는 기회를 제공하며, 모든 영속적인 상태가 메모리상의 현재 서블릿의 상태와 확실히 동기화할 수 있게끔 한다.
4. getServletConfig
5. getServletInfo


## 참고 문헌
- [아파치 톰캣 버전](http://adminid.kr/apache/50534)
- [[IT/트랜드] Apache Tomcat 활용하기 ① (Tomcat 설치하기)](https://daitso.kbhub.co.kr/60434/)
- [HTTP의 진화](https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP)
