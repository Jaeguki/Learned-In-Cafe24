
# 중재자 패턴 (Mediator pattern)
### 작성자
	 임수빈
## 중재자 패턴(Mediator pattern)이란? 
모든 클래스간의 복잡한 로직(상호작용)을 캡슐화하여 하나의 클래스에 위임하여 처리하는 패턴

한 집합에 속해있는 객체들의 상호작용을 캡슐화하는 객체를 정의하는 패턴. 

프로그램의 실행 행위를 변경할 수 있기 때문에 행위 패턴으로 간주됨.

**객체들이 직접 서로를 참조하지 않도록 함**으로써 객체들사이의 소결합(loose coupling)을 촉진시키며, 개발자가 객체들의 상호작용을 독립적으로 다양화시킬 수 있게함.

 *loose couling	
 
## 문제 - 언제 패턴을 사용하는가?
프로그램을 작성하다보면, 상호작용을 해야하는 경우,
객체들 간의 결합도가 증가하고 유연성이 떨어짐.

서로 명령을 주고 받을 수 있는 형식이 있다고 했을 떄,
서로 명령을 주고 받는 부분을 중재하는 형식을 정의하게됨. 
원래 서로 명령을 주고 받았던 개체들은 중재자 개체를 알게 하고, 중재자 개체는 이들 개체를 알게함.
특정 개체가 명령을 내릴 필요가 있으면 중재자 개체에게 전달하기만 하면 됨. 중재자는 해당 명령을 자신이 알고 있는 개체들 중에 적절한 개체에게 전달만 하면 됨.
이처럼 중재자 패턴을 사용하면 복잡한 상호작용을 하기 위한 복잡한 관계를 단순화시킬 수 있게 됨.

## 해결방안 - 설계를 구성하는 요소간의 관계 (클래스다이어그램)

## 결과 - 적용해서 얻는 결과
 
### - 장점

**서브클래스를 제한함.**
중재자는 다른 객체 사이에 분산된 객체의 행동들을 하나의 객체로 제한함.
행동을 변경하고자 한다면, Mediator클래스를 상속하는
서브클래스만 만들면 됨.
**Colleague객체 사이의 종속성을 줄입니다.**
 중재자는 행동에 참여하는 객체간의 Loose Coupling을 증진시킴. Mediator 클래스와 Colleague 클래스 각각을 독립적으로 다양화시킬 수 있고 재사용할 수 있음.
**객체 프로토콜을 단순화함**
 M:N의 관계에서 M:1의 관계로 복잡도를 떨어뜨려 유지 보수 및 재사용의 확장성에 유리하다.
복잡한 상호작용을 하기 위한 복잡한 관계를 단순화 시킬 수 있다.
**객체간의 협력 방법을 추상화함**
객체 사이의 중재를 독립적인 개념으로 만들고 이것을 캡슐화함으로써, 사용자는 각 객체의 행동과 상관없이 객체간 연결 방법에만 집중할 수있다.


### - 단점 
 **통제가 집중화됨**
 상호작용의 복잡한 모든 것들이 자신 내부에서만 오가게함. 중재자 객체는 동료 객체간의 상호작용에 관련된 프로토콜을 모두 캡슐화하기 때문에, 훨씬 복잡해질 수 있음. Mediator클래스 자체의 유지보수가 어려워지게 될때도 있음.
 
 ### *구현시 고려해야 할 이슈
 1. Mediator 생략
    : 만약 관련 객체들이 오직 하나의 Mediator클래스와 동작한다면 Mediator를 추상화할 필요가 없음.
    추상클래스의 목적은 또 다른 상호작용을 정의할 새로운 Medator 서브클래스를 만들 때 필요
   
   2. Colleague-Mediator간의 의사소통
      : 필요한 이벤트가 발생할 때 Colleague클래스는 Mediator 클래스와 자료를 주고 받아야 함. 중재자 클래스를 구현하는 한가지 방법은 Observer 패턴을 사용하는 방법임
## 코드 예제


**관련 패턴
Facade 
Observer
### 참고문헌 
[https://newsdu.tistory.com/entry/GoF%EB%94%94%ED%8C%A8-17-%EC%A4%91%EC%9E%AC%EC%9E%90Mediator-%ED%8C%A8%ED%84%B4](https://newsdu.tistory.com/entry/GoF%EB%94%94%ED%8C%A8-17-%EC%A4%91%EC%9E%AC%EC%9E%90Mediator-%ED%8C%A8%ED%84%B4)